-- I hope there are enough comments now.

--|| Services ||--
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Get reference to ReplicatedStorage service

--|| Folders ||--
local remotes = ReplicatedStorage.Remotes -- Reference to Remotes folder in ReplicatedStorage
local modules = ReplicatedStorage.Modules -- Reference to Modules folder in ReplicatedStorage

--|| Modules ||--
local loopsModule = require(modules.Loops) -- Load Loops module for frame-based loop functionality

--|| Variables ||--
local gameFPS = 60 -- Base frames per second value for calculations
local oneFrame = 1/gameFPS -- Calculate duration of one frame in seconds

-- Create overlap parameters for map collision detection
local mapParams = OverlapParams.new() -- Instantiate new OverlapParams object
mapParams.FilterType = Enum.RaycastFilterType.Include -- Set filter to include only specified items
mapParams.FilterDescendantsInstances = {workspace.Map} -- Only check collisions with workspace.Map

-- Module initialization
local module = {} -- Create table to hold module functions
module.__index = module -- Set metatable for OOP functionality

-- Type definitions for type checking and documentation
export type newData = { -- Define type for new projectile data
	Velocity: Vector3 | (first: boolean?) -> Vector3,
	RotationOffset: CFrame?,
	lastTime: number?,
	hitboxSize: Vector3,
	multiHit: boolean?,
	ignoreWalls: boolean?,
	hitboxOffset: CFrame?,
	DestroyOnHit: boolean?,
	OneTarget: (boolean | Model)?,
	FPS: number?
}

export type data = { -- Define type for active projectile data
	Velocity: Vector3 | () -> Vector3,
	velocityFunction: ((first: boolean?) -> Vector3)?,
	despawnFunction: ((projectile: Model, hitSomething: boolean?, hitMap: boolean?) -> nil)?,
	RotationOffset: CFrame?,
	hitboxPart: BasePart?,
	hitboxOffset: CFrame?,
	hitFunction: (hitCharacter: Model) -> boolean?,
	model: Model | BasePart,
	lastTime: number,
	removing: boolean?,
	alreadyHit: {Model?},
	multiHit: boolean?,
	oneTarget: (boolean | Model)?,
	timePassed: number,
	ignoreWalls: boolean?,
	destroyOnHit: boolean,
	hitboxId: number,
	owner: Model
}

local Projectiles = {} -- Table to track all active projectiles

-- Create combined overlap parameters for character detection
local combinedParams = OverlapParams.new() -- Instantiate new OverlapParams object
combinedParams.FilterType = Enum.RaycastFilterType.Include -- Set filter to include only specified items
combinedParams.FilterDescendantsInstances = {workspace.Living} -- Only check collisions with living characters

-- Function to validate hits against characters and destructibles
local function checkHitbox(PartsHit: {BasePart}, IgnoreList: {Instance}, CombatInfo: {})
	local CharactersHit = {} -- Table to store valid character targets
	local Checked = {} -- Table to track processed models to avoid duplicates

	-- Determine if destructibles should be ignored based on CombatInfo
	local IgnoreDestructibles = not (CombatInfo and CombatInfo.Damage) -- Check if damage is specified
	local CombatInfo = CombatInfo -- Redundant declaration for type checking assistance

	-- Loop through all collided parts
	for _, Part in PartsHit do -- Iterate through each part in PartsHit table
		local Model = Part:FindFirstAncestorOfClass("Model") -- Find parent model of collided part
		-- Skip if model is invalid or already processed
		if not Model or table.find(Checked, Model) then continue end -- Continue to next iteration

		-- Check if model is in ignore list
		local IsIgnored = table.find(IgnoreList, Model) -- Check direct ignore list
		if not IsIgnored then -- If not directly ignored, check ancestry
			-- Check if model is descendant of any ignored instances
			for _, Ignored in IgnoreList do -- Iterate through ignore list
				if not Model:IsDescendantOf(Ignored) then continue end -- Check parentage
				IsIgnored = true -- Mark as ignored if descendant
				break -- Exit ignore check loop
			end -- End of ignore check loop
		end -- End of ignore check block

		-- Handle ignored models
		if IsIgnored then -- If model should be ignored
			table.insert(Checked, Model) -- Add to processed list
			continue -- Skip to next iteration
		end -- End of ignore handling block

		-- Check for humanoid-containing models
		local Humanoid = Model:FindFirstChild("Humanoid") -- Find humanoid in model
		if Humanoid then -- If humanoid exists
			table.insert(Checked, Model) -- Mark model as processed
			-- Check if humanoid is alive and in Living folder
			if Humanoid.Health > 0 and Model:FindFirstAncestor("Living") then -- Validate target
				table.insert(CharactersHit, Model) -- Add to valid targets
			end -- End of alive check
			continue -- Skip destructible checks
		elseif IgnoreDestructibles then -- If ignoring destructibles
			continue -- Skip to next iteration
		end -- End of humanoid/destructible check block
	end -- End of parts loop

	return CharactersHit -- Return validated character targets
end -- End of checkHitbox function

-- Main projectile update function
local function updateProjectile(deltaTime: number, projectileData: data)
	-- Local variable caching for performance
	local timePassed = projectileData.timePassed -- Get current lifetime
	local model = projectileData.model -- Reference to projectile visual
	local projectileOwner = projectileData.owner -- Reference to projectile owner
	local velocityFunction = projectileData.velocityFunction -- Velocity calculation function
	local despawnFunction = projectileData.despawnFunction -- Custom despawn handler
	local hitFunction = projectileData.hitFunction -- Hit validation function
	local ignoreWalls = projectileData.ignoreWalls -- Wall collision flag
	local oneTarget = projectileData.oneTarget -- Single target restriction
	local destroyOnHit = projectileData.destroyOnHit ~= false -- Destruction flag (default true)
	local hitboxId = projectileData.hitboxId -- Unique hitbox identifier
	local hitboxPart = projectileData.hitboxPart -- Collision detection part

	-- Check for expiration conditions
	if (timePassed >= projectileData.lastTime or model:GetAttribute("Stop")) and not projectileData.removing then
		hitboxPart:Destroy() -- Remove collision part

		-- Handle custom despawn logic
		if despawnFunction then -- If custom despawn exists
			projectileData.removing = true -- Mark as removing
			task.spawn(function() -- Run in separate thread
				despawnFunction(model, false) -- Call despawn callback
				model:Destroy() -- Destroy visual
			end) -- End of task.spawn
			return false -- Signal to stop updates
		else -- Default destruction
			model:Destroy() -- Destroy visual immediately
			return false -- Signal to stop updates
		end -- End of despawn check
	end -- End of expiration check

	-- Calculate dynamic velocity
	local velocityFunctionResult -- Stores velocity calculation
	if velocityFunction then -- If using velocity function
		local resultFunction = velocityFunction(false, oneFrame) -- Get velocity
		if not projectileData.removing then -- Check if still active
			velocityFunctionResult = resultFunction -- Store result
		end -- End of removal check
	end -- End of velocity function check

	-- Update hitbox position
	local projectileCFrame -- Stores current position
	if model:IsA("Model") then -- Handle model instances
		projectileCFrame = model:GetPivot() -- Get model pivot
	elseif model:IsA("BasePart") then -- Handle single parts
		projectileCFrame = model.CFrame -- Get part CFrame
	end -- End of model type check
	hitboxPart.CFrame = projectileCFrame -- Sync hitbox position

	-- Process collisions if active
	if not projectileData.removing then -- Check if not being removed
		-- Update velocity from function
		if velocityFunction then -- Velocity function exists
			projectileData.Velocity = velocityFunctionResult -- Update velocity
		end -- End of velocity function update

		-- Detect character collisions
		local charactersHit = checkHitbox(
			workspace:GetPartBoundsInBox(projectileCFrame * projectileData.hitboxOffset, hitboxPart.Size, combinedParams),
			{projectileOwner}
		) -- Get valid targets
		local hit = false -- Hit flag
		local hitWall = false -- Wall collision flag

		-- Process hit characters
		for _, v in charactersHit do -- Iterate through hits
			-- Handle multi-hit restrictions
			if not projectileData.multiHit then -- Single-hit mode
				-- Check single target restrictions
				if typeof(oneTarget) == "Instance" and v ~= oneTarget then -- Wrong target
					continue -- Skip processing
				end -- End of wrong target check

				-- Check already hit targets
				if typeof(oneTarget) == "boolean" and projectileData.alreadyHit[1] or table.find(projectileData.alreadyHit, v) then
					continue -- Skip already hit
				end -- End of already hit check

				table.insert(projectileData.alreadyHit, v) -- Register hit
			end -- End of multi-hit check

			-- Execute hit callback
			local result = hitFunction(v, not hit) -- Call hit handler
			if result then -- If hit was successful
				hit = true -- Mark as hit
			end -- End of result check
		end -- End of character loop

		-- Check for wall collisions if no characters hit
		if not hit then -- Only check walls if no characters hit
			local partsHit = workspace:GetPartsInPart(hitboxPart, mapParams) -- Get map parts
			local hitPart = partsHit[1] -- Get first collision
			hitWall = hitPart ~= nil and hitPart.CanCollide -- Validate wall collision
		end -- End of wall check

		-- Handle collision consequences
		if hit or (hitWall and not ignoreWalls) then -- Valid collision
			projectileData.Velocity = Vector3.zero -- Stop movement
			hitboxPart:Destroy() -- Remove collision part
			projectileData.removing = true -- Mark for removal

			-- Handle custom despawn
			if despawnFunction then -- Custom despawn exists
				task.spawn(function() -- Run in separate thread
					despawnFunction(model, hit, hitWall) -- Call despawn callback
					if destroyOnHit then -- Check destruction flag
						model:Destroy() -- Destroy visual
					end -- End of destruction check
				end) -- End of task.spawn
				return false -- Signal to stop updates
			else -- Default handling
				if destroyOnHit then -- Check destruction flag
					model:Destroy() -- Destroy visual
				end -- End of destruction check
				return false -- Signal to stop updates
			end -- End of despawn check
		end -- End of collision check
	end -- End of active projectile check

	-- Calculate next position
	local velocity = projectileData.Velocity -- Current velocity
	local nextCFrame = projectileCFrame + (velocity * deltaTime) -- Calculate new position

	-- Apply movement if not forced to stop
	if not model:GetAttribute("forceProjectileStop") then -- Check stop attribute
		if model:IsA("Model") then -- check model's class is "Model"
			model:PivotTo(nextCFrame) -- Move model
		elseif model:IsA("BasePart") then -- check model's class is BasePart
			model.CFrame = nextCFrame -- Move part
		end -- End of model type check
	end -- End of movement check

	projectileData.timePassed += deltaTime -- Update lifetime timer
	return true -- Continue updates
end -- End of updateProjectile function

-- Projectile constructor
function module.new(owner: Model, projectileModelorPart: Model | BasePart, from: Vector3, data: newData, hitFunction: (hitCharacter: Model) -> boolean?, despawnFunction: ((projectile: Model, hitSomething: boolean?, hitMap: boolean?) -> nil)?)
	local projectileId = math.random() -- Generate unique ID
	local model = projectileModelorPart -- Reference to projectile model

	-- Initialize projectile data structure
	local projectileData = { -- Create projectile state table
		Velocity = if type(data.Velocity) == "vector" then data.Velocity elseif type(data.Velocity) == "function" then Vector3.zAxis else Vector3.zAxis,
		velocityFunction = if type(data.Velocity) == "function" then data.Velocity else nil,
		hitboxPart = nil,
		hitboxOffset = data.hitboxOffset or CFrame.new(),
		despawnFunction = despawnFunction,
		RotationOffset = data.RotationOffset or CFrame.new(),
		owner = owner,
		projectileId = projectileId,
		hitFunction = hitFunction,
		model = model,
		multiHit = data.multiHit,
		oneTarget = data.OneTarget,
		alreadyHit = {},
		lastTime = data.lastTime or 2, -- Default 2 second lifespan
		timePassed = 0,
		ignoreWalls = data.ignoreWalls or false,
		destroyOnHit = data.DestroyOnHit,
		hitboxId = math.random()
	}

	-- Initialize velocity from function
	if projectileData.velocityFunction then -- If using velocity function
		projectileData.Velocity = projectileData.velocityFunction(true, oneFrame) -- calculate velocity via function
	end -- End of velocity function check

	-- Setup owner destruction cleanup
	local desctructionConnect -- Connection reference
	desctructionConnect = owner.AncestryChanged:Connect(function(child, parent) -- Listen for owner removal
		if not parent then -- If owner is destroyed
			model:Destroy() -- Destroy projectile
			desctructionConnect:Disconnect() -- Cleanup connection
			desctructionConnect = nil -- Clear reference
		end -- End of parent check
	end) -- End of connection

	-- Calculate CFrame
	local lookAt = CFrame.lookAt(from, from + projectileData.Velocity) * projectileData.RotationOffset
	if model:IsA("Model") then -- check model's class is "Model"
		model:PivotTo(lookAt) -- Position model
	elseif model:IsA("BasePart") then -- check model's class is BasePart
		model.CFrame = lookAt -- Position part
	end -- End of model type check
	model.Parent = workspace.Projectiles -- Place in projectiles folder

	-- Create collision hitbox
	local hitboxPart = Instance.new("Part") -- Create new part
	hitboxPart.Size = data.hitboxSize or Vector3.one -- Set hitbox size
	hitboxPart.CFrame = lookAt -- Position hitbox
	projectileData.hitboxPart = hitboxPart -- Store reference
	Projectiles[model] = projectileData -- Register projectile

	-- Start update loop
	local loop = loopsModule.new(function(loopSelf, deltaTime: number) -- Create new loop
		if not updateProjectile(deltaTime, projectileData) then -- Update projectile
			loopSelf:Break() -- Stop loop if update fails
		end -- End of update check
	end, data.FPS or 60) -- Set update frequency

	-- Create control interface
	local self = {} -- Public methods table
	function self:Destroy() -- Manual destruction method
		hitboxPart:Destroy() -- Remove hitbox
		loop:Break() -- Stop update loop
		model:Destroy() -- Remove visual
		desctructionConnect:Disconnect() -- Cleanup connection
		Projectiles[model] = nil -- Unregister projectile
		desctructionConnect = nil -- Clear reference
	end -- End of Destroy method

	return self -- Return control interface
end -- End of new method

-- Projectile retrieval function
function module.GetProjectileFromModel(Model: BasePart | Model): data? -- May return nil
	return Projectiles[Model] -- Lookup in registry
end -- End of GetProjectileFromModel

return module -- Return completed module
